---
layout: single
title:  "01 PyTorch_basic"
categories: PyTorch
tag: [Pytorch,basic]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


# PyTorch
<iframe width="560" height="315" src="https://www.youtube.com/embed/C1P7PaIeKvU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
Jupyter Notebook 자료 : https://drive.google.com/file/d/18rxNUsEN_PDpLo6V67SiMkQJIascrBqL/view?usp=share_link
## 파이토치의 구성요소



- `torch`: 텐서를 생성하는 라이브러리



- `torch.autograd`: 자동미분 기능을 제공하는 라이브러리



- `torch.nn`: 신경망을 생성하는 라이브러리



- `torch.multiprocessing`: 병럴처리 기능을 제공하는 라이브러리



- `torch.utils`: 데이터 조작 등 유틸리티 기능 제공



- `torch.legacy`(./nn/.optim): Torch로부터 포팅해온 코드



- `torch.onnx`: ONNX(Open Neural Network Exchange)



  - 서로 다른 프레임워크 간의 모델을 공유할 때 사용


## 텐서(Tensors)

- 넘파이(NumPy)의 ndarray와 유사



- GPU를 사용한 연산 가속도 가능



```python
import torch
```


```python
torch.__version__
```

<pre>
'1.13.1'
</pre>
### 초기화 되지 않은 행렬 



```python
x = torch.empty(4,2)
print(x)
```

<pre>
tensor([[8.3963e-07, 1.3096e-11],
        [2.7149e-06, 8.2292e-10],
        [5.4655e+22, 2.5232e-09],
        [4.3199e-05, 1.0622e-05]])
</pre>
왜 값들이 있지?  

메모리에서 기존에 사용하던 값들이 남아 있기때문에(초기화를 안해서)


### 무작위로 초기화된 행렬



```python
x = torch.rand(4,2)
print(x)
```

<pre>
tensor([[0.9287, 0.6955],
        [0.5765, 0.8876],
        [0.9400, 0.7742],
        [0.8820, 0.1920]])
</pre>
### dtype이 long, 0으로 채워진 텐서



```python
x = torch.zeros(4,2, dtype = torch.long)
print(x)
```

<pre>
tensor([[0, 0],
        [0, 0],
        [0, 0],
        [0, 0]])
</pre>
### 직접 tensor 설정



```python
x = torch.tensor([3,2.3])
print(x)
```

<pre>
tensor([3.0000, 2.3000])
</pre>
### dtype이 double, 1으로 채워진 텐서



```python
x = x.new_ones(2,4, dtype = torch.double) #double은 float64와 matching 됨
print(x)
```

<pre>
tensor([[1., 1., 1., 1.],
        [1., 1., 1., 1.]], dtype=torch.float64)
</pre>
### 크기를 가져오기, random



```python
x = torch.randn_like(x, dtype = torch.float)
print(x)
```

<pre>
tensor([[-1.4304,  1.0057, -2.3193, -1.2819],
        [ 0.3103,  0.2430,  0.3736, -1.4636]])
</pre>
### 텐서의 크기



```python
print(x.size())
```

<pre>
torch.Size([2, 4])
</pre>
## 텐서의 연산(operations)


### 덧셈 1



```python
print(x)
```

<pre>
tensor([[-1.4304,  1.0057, -2.3193, -1.2819],
        [ 0.3103,  0.2430,  0.3736, -1.4636]])
</pre>

```python
y = torch.rand(2,4)
print(y)
print(x+y)
```

<pre>
tensor([[0.5824, 0.7455, 0.3521, 0.0194],
        [0.3802, 0.4864, 0.6334, 0.3946]])
tensor([[-0.8480,  1.7512, -1.9672, -1.2625],
        [ 0.6905,  0.7294,  1.0070, -1.0690]])
</pre>
### 덧셈2



```python
print(torch.add(x,y))
```

<pre>
tensor([[-0.8480,  1.7512, -1.9672, -1.2625],
        [ 0.6905,  0.7294,  1.0070, -1.0690]])
</pre>
### 덧셈3

- 결과 텐서를 인자로 제공



```python
result = torch.empty(2,4)
torch.add(x,y, out = result)
print(result)
```

<pre>
tensor([[-0.8480,  1.7512, -1.9672, -1.2625],
        [ 0.6905,  0.7294,  1.0070, -1.0690]])
</pre>
### 덧셈4

- `in-place` 방식



- (참고) in-place 방식

  - in-place방식으로 텐서의 값을 변경하는 연산 뒤에는 _''가 붙음

  - `x.copy_(y), x.t_()`



```python
print(x)
print(y)
```

<pre>
tensor([[-1.4304,  1.0057, -2.3193, -1.2819],
        [ 0.3103,  0.2430,  0.3736, -1.4636]])
tensor([[0.5824, 0.7455, 0.3521, 0.0194],
        [0.3802, 0.4864, 0.6334, 0.3946]])
</pre>

```python
y.add_(x) #y += x
```

<pre>
tensor([[-0.8480,  1.7512, -1.9672, -1.2625],
        [ 0.6905,  0.7294,  1.0070, -1.0690]])
</pre>

```python
print(y)
```

<pre>
tensor([[-0.8480,  1.7512, -1.9672, -1.2625],
        [ 0.6905,  0.7294,  1.0070, -1.0690]])
</pre>
### 그 외의 연산

- `torch.sub` : 뺄셈



```python
x = torch.Tensor([[1,3],
                 [5,7]])
y = torch.Tensor([[2,4],
                 [6,8]])
print(x-y)
print(torch.sub(x,y))
print(x.sub(y))
```

<pre>
tensor([[-1., -1.],
        [-1., -1.]])
tensor([[-1., -1.],
        [-1., -1.]])
tensor([[-1., -1.],
        [-1., -1.]])
</pre>
- `torch.mul` : 곱셉



```python
x = torch.Tensor([[1,3],
                 [5,7]])
y = torch.Tensor([[2,4],
                 [6,8]])
print(x*y)
print(torch.mul(x,y))
print(x.mul(y))
```

<pre>
tensor([[ 2., 12.],
        [30., 56.]])
tensor([[ 2., 12.],
        [30., 56.]])
tensor([[ 2., 12.],
        [30., 56.]])
</pre>
- `torch.div` : 나눗셈



```python
x = torch.Tensor([[1,3],
                 [5,7]])
y = torch.Tensor([[2,4],
                 [6,8]])
print(x/y)
print(torch.div(x,y))
print(x.div(y))
```

<pre>
tensor([[0.5000, 0.7500],
        [0.8333, 0.8750]])
tensor([[0.5000, 0.7500],
        [0.8333, 0.8750]])
tensor([[0.5000, 0.7500],
        [0.8333, 0.8750]])
</pre>
- `torch.mm` : 내적(dot product)



```python
x = torch.Tensor([[1,3],
                 [5,7]])
y = torch.Tensor([[2,4],
                 [6,8]])
print(torch.mm(x,y))
```

<pre>
tensor([[20., 28.],
        [52., 76.]])
</pre>
## 텐서의 조작(manipulations)


### 인덱싱

- 넘파이처럼 인덱싱 사용가능



```python
print(x)
```

<pre>
tensor([[1., 3.],
        [5., 7.]])
</pre>

```python
print(x[:,1])
```

<pre>
tensor([3., 7.])
</pre>
### view

- 텐서의 크기(size)나 모양(shape)을 변경



```python
x = torch.randn(4,5)
y = x.view(20)                #1차원 형태로 출력
z = x.view(5,-1)              #5에서 자동으로 맞춰줌 (5,4)

print(x)
print(y)
print(z)
```

<pre>
tensor([[ 0.6061, -0.8990,  0.6559,  0.1679, -0.4512],
        [ 1.4598, -1.0466,  0.9451, -1.0775, -1.0821],
        [ 0.2165, -0.2027,  1.4532,  0.8834,  0.2127],
        [ 0.5820, -0.3024,  1.0001, -0.3088, -0.9814]])
tensor([ 0.6061, -0.8990,  0.6559,  0.1679, -0.4512,  1.4598, -1.0466,  0.9451,
        -1.0775, -1.0821,  0.2165, -0.2027,  1.4532,  0.8834,  0.2127,  0.5820,
        -0.3024,  1.0001, -0.3088, -0.9814])
tensor([[ 0.6061, -0.8990,  0.6559,  0.1679],
        [-0.4512,  1.4598, -1.0466,  0.9451],
        [-1.0775, -1.0821,  0.2165, -0.2027],
        [ 1.4532,  0.8834,  0.2127,  0.5820],
        [-0.3024,  1.0001, -0.3088, -0.9814]])
</pre>
### item

- 텐서에 값이 단 하나라도 존재하면 숫자값을 얻을 수 있음



```python
x = torch.randn(1)
print(x)
print(x.item())
print(x.dtype)
```

<pre>
tensor([0.3541])
0.3541457951068878
torch.float32
</pre>
- 스칼라값 하나만 존재해야함



```python
x = torch.randn(2)
print(x)
print(x.item())
print(x.dtype)
```

<pre>
tensor([0.4228, 2.3380])
</pre>
위와 같이 value error가 나온다.


### squeeze 

- 차원을 축소(제거)



```python
tensor = torch.rand(1,3,3)
print(tensor)
tensor.shape
```

<pre>
tensor([[[0.9026, 0.8963, 0.0764],
         [0.0432, 0.5478, 0.8179],
         [0.8575, 0.2416, 0.2428]]])
</pre>
<pre>
torch.Size([1, 3, 3])
</pre>

```python
t = tensor.squeeze()
print(t)
print(t.shape)
```

<pre>
tensor([[0.9026, 0.8963, 0.0764],
        [0.0432, 0.5478, 0.8179],
        [0.8575, 0.2416, 0.2428]])
torch.Size([3, 3])
</pre>
### unsqueeze

- 차원을 증가(생성)



```python
tensor = torch.rand(1,3,3)
print(tensor)
print(tensor.shape)
```

<pre>
tensor([[[0.2722, 0.4531, 0.4776],
         [0.1107, 0.8569, 0.2603],
         [0.3568, 0.8056, 0.6061]]])
torch.Size([1, 3, 3])
</pre>

```python
t = tensor.unsqueeze(dim=0)

print(t)
print(t.shape)
```

<pre>
tensor([[[[0.2722, 0.4531, 0.4776],
          [0.1107, 0.8569, 0.2603],
          [0.3568, 0.8056, 0.6061]]]])
torch.Size([1, 1, 3, 3])
</pre>
### stack

- 텐서간 결합



```python
x = torch.FloatTensor([1,4])
y = torch.FloatTensor([2,5])
z = torch.FloatTensor([3,6])

print(torch.stack([x,y,z]))
```

<pre>
tensor([[1., 4.],
        [2., 5.],
        [3., 6.]])
</pre>
### cat

- 텐서를 결합하는 메소드(concatenate)



- 넘파이의 `stack`과 유사하지만, 쌓을 dim이 존재해야함

  - 예를 들어, 해당 차원을 늘려준 후 결합



```python
a = torch.randn(1,1,3,3)
b = torch.randn(1,1,3,3)
c = torch.cat((a,b), dim=0)

print(c)
print(c.size())
```

<pre>
tensor([[[[ 0.9532, -0.1595,  0.6249],
          [ 0.7685,  2.1396,  0.6100],
          [-0.1754,  0.9931,  1.3237]]],


        [[[-0.8021, -1.3837,  0.2611],
          [ 0.7174,  0.0640,  0.4060],
          [-0.2178,  0.8511,  0.2849]]]])
torch.Size([2, 1, 3, 3])
</pre>

```python
a = torch.randn(1,3,3)
b = torch.randn(1,3,3)
c = torch.cat((a,b), dim=0)

print(c)
print(c.size())
```

<pre>
tensor([[[ 1.5737, -0.4823,  0.3503],
         [-0.7009,  0.1727,  0.4802],
         [-0.5022, -0.1549,  0.1270]],

        [[-0.5350, -1.1476, -0.4902],
         [ 0.3595, -0.8240, -0.1338],
         [ 0.0428, -1.1976,  0.3360]]])
torch.Size([2, 3, 3])
</pre>

```python
a = torch.randn(1,3,3)
b = torch.randn(1,3,3)
c = torch.cat((a,b), dim=1)

print(c)
print(c.size())
```

<pre>
tensor([[[ 0.4245,  0.6555, -0.4812],
         [ 1.6631,  1.7782,  0.7647],
         [-1.6790, -0.7275,  0.4619],
         [ 0.0582,  1.3915,  0.1683],
         [-0.0424,  0.2972,  0.0914],
         [-0.0343, -0.2753,  0.3673]]])
torch.Size([1, 6, 3])
</pre>

```python
a = torch.randn(1,3,3)
b = torch.randn(1,3,3)
c = torch.cat((a,b), dim=2)

print(c)
print(c.size())
```

<pre>
tensor([[[ 1.5208e+00, -4.3003e-01,  1.8029e+00, -4.4283e-01,  4.8101e-01,
          -6.8171e-01],
         [-8.2699e-01, -1.0426e-01,  3.6417e-04, -6.8313e-01, -2.3064e+00,
          -1.4573e-01],
         [ 1.6829e+00,  2.9566e-01,  1.8273e-01, -1.5350e+00, -2.5912e-01,
          -6.0058e-01]]])
torch.Size([1, 3, 6])
</pre>
### chunk

- 텐서를 여러 개로 나눌 때 사용



- 몇 개의 텐서로 나눌 것이냐



```python
tensor = torch.rand(3,6)
t1, t2, t3 = torch.chunk(tensor,3,dim=1)   #chunk의 갯수를 지정(여기서는 3으로 지정)

print(tensor)
print(t1)
print(t2)
print(t3)
```

<pre>
tensor([[0.2332, 0.5900, 0.1304, 0.1003, 0.0516, 0.3229],
        [0.4923, 0.5801, 0.5657, 0.1626, 0.3260, 0.8235],
        [0.1637, 0.6084, 0.0564, 0.7413, 0.9358, 0.7032]])
tensor([[0.2332, 0.5900],
        [0.4923, 0.5801],
        [0.1637, 0.6084]])
tensor([[0.1304, 0.1003],
        [0.5657, 0.1626],
        [0.0564, 0.7413]])
tensor([[0.0516, 0.3229],
        [0.3260, 0.8235],
        [0.9358, 0.7032]])
</pre>
### split

- `chunck`와 동일한 기능이지만 조금 다름



- 하나의 텐서당 크기가 얼마이냐



```python
tensor = torch.rand(3,6)
t1, t2 = torch.split(tensor, 3, dim=1)

print(tensor)
print(t1)
print(t2)
```

<pre>
tensor([[0.5338, 0.9532, 0.2829, 0.6339, 0.5045, 0.5878],
        [0.8510, 0.6235, 0.8536, 0.1738, 0.9994, 0.9600],
        [0.7474, 0.8303, 0.9611, 0.6055, 0.7909, 0.9858]])
tensor([[0.5338, 0.9532, 0.2829],
        [0.8510, 0.6235, 0.8536],
        [0.7474, 0.8303, 0.9611]])
tensor([[0.6339, 0.5045, 0.5878],
        [0.1738, 0.9994, 0.9600],
        [0.6055, 0.7909, 0.9858]])
</pre>
### torch ↔ numpy

- Torch Tensor(텐서)를 Numpy array(배열)로 변환 가능



  - `numpy()`

  - `from_numpy()`



- (참고)

  - Tensor가 CPU상에 있다면 Numpy 배열은 메모리 공간을 공유하므로 하나가 변하면, 다른 하나도 변함



```python
a = torch.ones(7)
print(a)
```

<pre>
tensor([1., 1., 1., 1., 1., 1., 1.])
</pre>

```python
b = a.numpy()
print(b)
```

<pre>
[1. 1. 1. 1. 1. 1. 1.]
</pre>

```python
a.add_(1)
print(a)
print(b)
```

<pre>
tensor([2., 2., 2., 2., 2., 2., 2.])
[2. 2. 2. 2. 2. 2. 2.]
</pre>
메모리를 공유하게 됨으로 같이 변한다.



```python
import numpy as np

a = np.ones(7)
b = torch.from_numpy(a)
np.add(a,1, out=a)
print(a)
print(b)
```

<pre>
[2. 2. 2. 2. 2. 2. 2.]
tensor([2., 2., 2., 2., 2., 2., 2.], dtype=torch.float64)
</pre>
## CUDA Tensors

- `.to` 메소드를 사용하여 텐서를 어떠한 장치로도 옮길 수 있음

  - 예) cpu, gpu



```python
import torch
```


```python
x = torch.randn(1)
print(x)
print(x.item())
print(x.dtype)
```

<pre>
tensor([-0.5335])
-0.5334987640380859
torch.float32
</pre>

```python
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

y = torch.ones_like(x, device=device)
x = x.to(device)
z = x+y
print(device)
print(z)
print(z.to("cpu", torch.double))
```

<pre>
cuda
tensor([0.4665], device='cuda:0')
tensor([0.4665], dtype=torch.float64)
</pre>
## AUTOGRAD (자동미분)

- autograd 패키지는 Tensor의 모든 연산에 대해 **자동 미분** 제공



- 이는 코드를 어떻게 작성하여 실행하느냐에 따라 역전파가 정의된다는 뜻



- backprop를 위한 미분값을 자동으로 계산


### Tensor



- data: tensor형태의 데이터



- grad: data가 겨쳐온 layer에 대한 미분값 저장



- grad_fn: 미분값을 계산한 함수에 대한 정보 저장 (어떤 함수에 대해서 backprop 했는지)



- `requires_grad` 속성을 `True`로 설정하면, 해당 텐서에서 이루어지는 모든 연산들을 추적하기 시작



- 계산이 완료된 후, `.backward()`를 호출하면 자동으로 `gradient`를 계산할 수 있으며, `.grad` 속성에 누적됨



- 기록을 추적하는 것을 중단하게 하려면, `.detach()`를 호출하여 연산기록으로부터 분리



- 기록을 추적하는 것을 방지하기 위해 코드 블럭을 `with torch.no_grad():`로 감싸면 `gradient`는 필요없지만, `requires_grad=True`로 설정되어 학습 가능한 매개변수를 갖는 모델을 평가(evaluate)할 때 유용



- Autograd 구현에서 매우 중요한 클래스 : `Function` 클래스



```python
import torch
```


```python
x = torch.ones(3,3,requires_grad=True)
print(x)
```

<pre>
tensor([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]], requires_grad=True)
</pre>

```python
y = x+5
print(y)
```

<pre>
tensor([[6., 6., 6.],
        [6., 6., 6.],
        [6., 6., 6.]], grad_fn=AddBackward0)
</pre>

```python
print(y.grad_fn)
```

<pre>
AddBackward0 object at 0x000002AA5995E610
</pre>

```python
z = y*y*2
out = z.mean()

print(z,out)
```

<pre>
tensor([[72., 72., 72.],
        [72., 72., 72.],
        [72., 72., 72.]], grad_fn=MulBackward0) tensor(72., grad_fn=MeanBackward0)
</pre>
- `requires_grad_(...)`는 기존 텐서의 `requires_grad`값을 바꿔치기(`in-place`)하여 변경



```python
a = torch.randn(3,3)
a = ((a*3) / (a-1))
print(a.requires_grad)

a.requires_grad_(True)
print(a.requires_grad)

b = (a*a).sum()
print(b.grad_fn)
```

<pre>
False
True
SumBackward0 object at 0x000002AA59A5E490
</pre>
### 기울기(Gradient)

- 역전파: `.backward()`를 통해 역전파 계산 가능



```python
out.backward()
```


```python
print(x.grad)
```

<pre>
tensor([[2.6667, 2.6667, 2.6667],
        [2.6667, 2.6667, 2.6667],
        [2.6667, 2.6667, 2.6667]])
</pre>

```python
x = torch.randn(3, requires_grad = True)

y = x*2
while y.data.norm() < 1000:
    y=y*2
    
print(y)
```

<pre>
tensor([928.7988, -58.0060, 700.3315], grad_fn=MulBackward0)
</pre>

```python
v = torch.tensor([0.1, 1.0, 0.0001], dtype = torch.float)
y.backward(v)

print(x.grad)
```

<pre>
tensor([1.0240e+02, 1.0240e+03, 1.0240e-01])
</pre>
- `with torch.no_grad()`를 사용하여 gradient의 업데이트를 하지 않음



```python
print(x.requires_grad)
print((x**2).requires_grad)

with torch.no_grad():
    print((x**2).requires_grad)
```

<pre>
True
True
False
</pre>
- `detach()`: 내용물(content)은 같지만 require_grad가 다른 새로운 Tensor를 가져올 때



```python
print(x.requires_grad)
y = x.detach()
print(y.requires_grad)
print(x.eq(y).all())
```

<pre>
True
False
tensor(True)
</pre>
### 자동 미분 흐름 다시 보기(1)

- 계산 흐름  

  $a \rightarrow b  \rightarrow c  \rightarrow out $



<br>



## $\quad \frac{\partial out}{\partial a} = ?$

- `backward()`를 통해  

  $a \leftarrow b  \leftarrow c  \leftarrow out $을 계산하면  

    $\frac{\partial out}{\partial a}$값이 `a.grad`에 채워짐




```python
import torch
```


```python
a = torch.ones(2,2)
print(a)
```

<pre>
tensor([[1., 1.],
        [1., 1.]])
</pre>

```python
a = torch.ones(2,2,requires_grad=True)
print(a)
```

<pre>
tensor([[1., 1.],
        [1., 1.]], requires_grad=True)
</pre>

```python
print("a.data:",a)
print("a.grad:",a.grad)
print("a.grad_fn:",a.grad_fn)
```

<pre>
a.data: tensor([[1., 1.],
        [1., 1.]], requires_grad=True)
a.grad: None
a.grad_fn: None
</pre>
- $b = a + 2$



```python
b = a+2
print(b)
```

<pre>
tensor([[3., 3.],
        [3., 3.]], grad_fn=AddBackward0)
</pre>
- $c = b^2$ 



```python
c = b**2
print(c)
```

<pre>
tensor([[9., 9.],
        [9., 9.]], grad_fn=PowBackward0)
</pre>

```python
out = c.sum()
print(out)
```

<pre>
tensor(36., grad_fn=SumBackward0)
</pre>

```python
print(out)
out.backward()
```

<pre>
tensor(36., grad_fn=SumBackward0)
</pre>
- a의 `grad_fn`이 None인 이유  

  직접적으로 계산한 부분이 없었기 때문



```python
print("a.data:",a)
print("a.grad:",a.grad)
print("a.grad_fn:",a.grad_fn)
```

<pre>
a.data: tensor([[1., 1.],
        [1., 1.]], requires_grad=True)
a.grad: tensor([[6., 6.],
        [6., 6.]])
a.grad_fn: None
</pre>

```python
print("b.data:",b)
print("b.grad:",b.grad)
print("b.grad_fn:",b.grad_fn)
```

<pre>
b.data: tensor([[3., 3.],
        [3., 3.]], grad_fn=AddBackward0)
b.grad: None
b.grad_fn: AddBackward0 object at 0x000002AA59D2C610
</pre>
<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_16136\1859589111.py:2: UserWarning: The .grad attribute of a Tensor that is not a leaf Tensor is being accessed. Its .grad attribute won't be populated during autograd.backward(). If you indeed want the .grad field to be populated for a non-leaf Tensor, use .retain_grad() on the non-leaf Tensor. If you access the non-leaf Tensor by mistake, make sure you access the leaf Tensor instead. See github.com/pytorch/pytorch/pull/30531 for more informations. (Triggered internally at C:\cb\pytorch_1000000000000\work\build\aten\src\ATen/core/TensorBody.h:485.)
  print("b.grad:",b.grad)
</pre>

```python
print("c.data:",c)
print("c.grad:",c.grad)
print("c.grad_fn:",c.grad_fn)
```

<pre>
c.data: tensor([[9., 9.],
        [9., 9.]], grad_fn=PowBackward0)
c.grad: None
c.grad_fn: PowBackward0 object at 0x000002AA59D184C0
</pre>
<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_16136\2383004956.py:2: UserWarning: The .grad attribute of a Tensor that is not a leaf Tensor is being accessed. Its .grad attribute won't be populated during autograd.backward(). If you indeed want the .grad field to be populated for a non-leaf Tensor, use .retain_grad() on the non-leaf Tensor. If you access the non-leaf Tensor by mistake, make sure you access the leaf Tensor instead. See github.com/pytorch/pytorch/pull/30531 for more informations. (Triggered internally at C:\cb\pytorch_1000000000000\work\build\aten\src\ATen/core/TensorBody.h:485.)
  print("c.grad:",c.grad)
</pre>

```python
print("out.data:",out)
print("out.grad:",out.grad)
print("out.grad_fn:",out.grad_fn)
```

<pre>
out.data: tensor(36., grad_fn=SumBackward0)
out.grad: None
out.grad_fn: SumBackward0 object at 0x000002AA511AC2B0
</pre>
<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_16136\158614923.py:2: UserWarning: The .grad attribute of a Tensor that is not a leaf Tensor is being accessed. Its .grad attribute won't be populated during autograd.backward(). If you indeed want the .grad field to be populated for a non-leaf Tensor, use .retain_grad() on the non-leaf Tensor. If you access the non-leaf Tensor by mistake, make sure you access the leaf Tensor instead. See github.com/pytorch/pytorch/pull/30531 for more informations. (Triggered internally at C:\cb\pytorch_1000000000000\work\build\aten\src\ATen/core/TensorBody.h:485.)
  print("out.grad:",out.grad)
</pre>
### 자동 미분 흐름 다시 보기(2)

- `grad`값을 넣어서 `backward`



- 아래의 코드에서 `.grad`값이 None은 gradient값이 필요하지 않기 때문



```python
x = torch.ones(3, requires_grad = True)
y = (x**2)
z = y**2 +x
out = z.sum()
print(out)
```

<pre>
tensor(6., grad_fn=SumBackward0)
</pre>

```python
grad = torch.Tensor([0.1,1,100])
z.backward(grad)
```


```python
print("x.data:",x)
print("x.grad:",x.grad)
print("x.grad_fn:",x.grad_fn)
```

<pre>
x.data: tensor([1., 1., 1.], requires_grad=True)
x.grad: tensor([  0.5000,   5.0000, 500.0000])
x.grad_fn: None
</pre>

```python
print("y.data:",y)
print("y.grad:",y.grad)
print("y.grad_fn:",y.grad_fn)
```

<pre>
y.data: tensor([1., 1., 1.], grad_fn=PowBackward0)
y.grad: None
y.grad_fn: PowBackward0 object at 0x000002AA59A37880
</pre>
<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_16136\1132046467.py:2: UserWarning: The .grad attribute of a Tensor that is not a leaf Tensor is being accessed. Its .grad attribute won't be populated during autograd.backward(). If you indeed want the .grad field to be populated for a non-leaf Tensor, use .retain_grad() on the non-leaf Tensor. If you access the non-leaf Tensor by mistake, make sure you access the leaf Tensor instead. See github.com/pytorch/pytorch/pull/30531 for more informations. (Triggered internally at C:\cb\pytorch_1000000000000\work\build\aten\src\ATen/core/TensorBody.h:485.)
  print("y.grad:",y.grad)
</pre>

```python
print("z.data:",z)
print("z.grad:",z.grad)
print("z.grad_fn:",z.grad_fn)
```

<pre>
z.data: tensor([2., 2., 2.], grad_fn=AddBackward0)
z.grad: None
z.grad_fn: AddBackward0 object at 0x000002AA5115EC40
</pre>
<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_16136\1960256943.py:2: UserWarning: The .grad attribute of a Tensor that is not a leaf Tensor is being accessed. Its .grad attribute won't be populated during autograd.backward(). If you indeed want the .grad field to be populated for a non-leaf Tensor, use .retain_grad() on the non-leaf Tensor. If you access the non-leaf Tensor by mistake, make sure you access the leaf Tensor instead. See github.com/pytorch/pytorch/pull/30531 for more informations. (Triggered internally at C:\cb\pytorch_1000000000000\work\build\aten\src\ATen/core/TensorBody.h:485.)
  print("z.grad:",z.grad)
</pre>
## nn & nn.functional



- 두 패키지가 같은 기능이지만 방식이 조금 다름



- 위의 `autograd` 관련 작업들을 두 패키지를 통해 진행할 수 있음



- 텐서를 직접 다룰 때 `requires_grad`와 같은 방식으로 진행할 수 있음



- 결론적으로, `torch.nn`은 attribute를 활용해 state를 저장하고 활용하고,  

  `torch.nn.functional`로 구현한 함수의 경우에는 인스턴스화 시킬 필요 없이 사용이 가능


### nn 패키지



- 주로 가중치(weights), 편향(bias)값들이 내부에서 자동으로 생성되는 레이어들을 사용할 때  

  - 따라서, `weight`값들을 직접 선언 안함



- 예시

  - Containers



  - Convolution Layers



  - Pooling layers



  - Padding Layers



  - Non-linear Activations (weighted sum, nonlinearity)



  - Non-linear Activations (other)



  - Normalization Layers



  - Recurrent Layers



  - Transformer Layers



  - Linear Layers



  - Dropout Layers



  - Sparse Layers



  - Distance Functions



  - Loss Functions



  - ..

- https://pytorch.org/docs/stable/nn.html






```python
import torch
import torch.nn as nn
```

- Convolution Layer 예시 (2)



```python
m = nn.Conv2d(16, 33, 3, stride=2)

m = nn.Conv2d(16, 33, (3,5), stride=(2,1), padding=(4,2))

m = nn.Conv2d(16, 33, (3,5), stride=(2,1), padding=(4,2), dilation=(3,1))

input = torch.randn(20,16,50,100)
output = m(input)
```


```python
output.shape
```

<pre>
torch.Size([20, 33, 26, 100])
</pre>
## nn.functional 패키지



- 가중치를 직접 선언하여 인자로 넣어줘야함



- 예시)

  - Convolution functions



  - Pooling functions

  

  - Non-linear activation functions



  - Normalization functions



  - Linear functions



  - Dropout functions

  

  - Sparse functions

  

  - Distance functions



  - Loss functions

  - ..



- https://pytorch.org/docs/stable/nn.functional.html



```python
import torch
import torch.nn.functional as F
```

- Convolution Layer 예시 (2)



```python
filters = torch.randn(8,4,3,3)
```


```python
inputs = torch.randn(1,4,5,5)
conv = F.conv2d(inputs, filters, padding=1)
conv.shape
```

<pre>
torch.Size([1, 8, 5, 5])
</pre>
## Torchvision



- `transforms`: 전처리할 때 사용하는 메소드



- `transforms`에서 제공하는 클래스 이외에  

  일반적으로 클래스를 따로 만들어 전처리 단계를 진행

  

  - 아래의 코드에서 다양한 전처리 기술 확인  

    https://pytorch.org/docs/stable/torchvision/transforms.html



```python
import torch
import torchvision
import torchvision.transforms as transforms
```

- 예시)

  - `DataLoader`의 인자로 들어갈 `transform`을 미리 정의할 수 있음



  - `Compose`를 통해 리스트 안에 순서대로 전처리 진행



  - 대표적인 예로, `ToTensor`()를 하는 이유는  

   <u>torchvision이 PIL Image형태로만 입력을 받기 때문에</u> 데이터 처리를 위해서 Tensor형으로 변환해야함



```python
transform = transforms.Compose([transforms.ToTensor(),
                              transforms.Normalize(mean=(0.5,), std=(0.5,))])
```

## utils.data



- `Dataset`에는 다양한 데이터셋이 존재  

  - MNIST, CIFAR10, ...



- `DataLoader`, `Dataset`을 통해  

  `batch_size`, `train`여부, `transform`등을 인자로 넣어 데이터를 어떻게 load할 것인지 정해줄 수 있음



```python
import torch
from torch.utils.data import Dataset, DataLoader

import torchvision
import torchvision.transforms as transforms
```


```python
trainset = torchvision.datasets.MNIST(root = 'MNIST_data/',
                                     train = True,
                                     download = True,
                                     transform = transform)

testset = torchvision.datasets.MNIST(root = 'MNIST_data/',
                                     train = False,
                                     download = True,
                                     transform = transform)
```


```python
train_loader = DataLoader(trainset, batch_size=8, shuffle = True, num_workers=2) #num_workers : 몇개의 코어 사용?
test_loader = DataLoader(testset, batch_size=8, shuffle = False, num_workers=2)
```

- `batch_size`만큼 데이터를 하나씩 가져옴



```python
detaiter = iter(train_loader)
images, labels = next(detaiter)
images.shape, labels.shape
```

<pre>
(torch.Size([8, 1, 28, 28]), torch.Size([8]))
</pre>
<u>**(중요) torch에서는 channel(채널)이 앞에 옴**</u>



- `channel first`



- tensorflow, keras 등에서는 channel이 뒤에 옴(`channel last`)


### 데이터 확인



```python
import matplotlib.pyplot as plt
```


```python
torch_image = torch.squeeze(images[0])
torch_image.shape
```

<pre>
torch.Size([28, 28])
</pre>

```python
image= torch_image.numpy()
image.shape
```

<pre>
(28, 28)
</pre>

```python
label = labels[0].numpy()
label.shape
```

<pre>
()
</pre>

```python
label
```

<pre>
array(1, dtype=int64)
</pre>

```python
plt.title(label)
plt.imshow(image,'gray')
plt.show()
```

<img src="data:image/png;base64,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"/>

## 각 Layer 설명



```python
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
```

### nn.Conv2d



- `in_channels`: channel의 갯수



- `out_channels`: 출력 채널의 갯수



- `kernel_size`: 커널(필터) 사이즈



- 텐서플로우, 케라스와 다르게 레이어의 `input`인자에도 값을 집어 넣어줘야함



```python
nn.Conv2d(in_channels=1, out_channels=20, kernel_size=5, stride=1)
```

<pre>
Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1))
</pre>

```python
layer = nn.Conv2d(1,20,5,1).to(torch.device('cpu'))
```

- `wegiht`확인



```python
weight = layer.weight
weight.shape
```

<pre>
torch.Size([20, 1, 5, 5])
</pre>
- `weight`는 `detach()`를 통해 꺼내줘야 `numpy()`변환이 가능



```python
weight = weight.detach()
```


```python
weight = weight.numpy()
weight.shape
```

<pre>
(20, 1, 5, 5)
</pre>

```python
plt.imshow(weight[0,0,:,:], 'jet')
plt.colorbar()
plt.show()
```

<img src="data:image/png;base64,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"/>


```python
print(images.shape)  #한번만 next했으므로 batch_size만큼만
```

<pre>
torch.Size([8, 1, 28, 28])
</pre>

```python
input_image = torch.unsqueeze(images[0],dim=0)
```


```python
output_data = layer(input_image)
```


```python
output = output_data.data
```


```python
output_arr = output.numpy()
output_arr.shape
```

<pre>
(1, 20, 24, 24)
</pre>

```python
plt.figure(figsize=(15,30))

plt.subplot(131)
plt.title("Input")
plt.imshow(image,'gray')
plt.subplot(132)
plt.title("Weight")
plt.imshow(weight[0,0,:,:],'jet')
plt.subplot(133)
plt.title("Output")
plt.imshow(output_arr[0,0,:,:],'gray')
```

<pre>
<matplotlib.image.AxesImage at 0x2aa862a1bb0>
</pre>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLIAAAGPCAYAAABIwPktAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjYuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8o6BhiAAAACXBIWXMAAA9hAAAPYQGoP6dpAAA6a0lEQVR4nO3de3RV9Zk//geEQLgoUG4dv1gvQCiCitIoBAV1qF1Wv4qIOIuhSBdai9WpU7GgtuBYSq2XKnY51aLj14ElVkeno8X7QIsV5CKDlIqiVlGjFkgBA4QQOL8/HPIzCho2SXZ2zuu1VtbyfM5+9n5Ojuyd/T6fvU+zXC6XCwAAAABo5Jqn3QAAAAAA1IYgCwAAAIBMEGQBAAAAkAmCLAAAAAAyQZAFAAAAQCYIsgAAAADIBEEWAAAAAJkgyAIAAAAgEwRZUM9yuVzaLQCQpxyDAKjvY4FjDQ1NkEWTdscdd0RRUVEq2/7ggw/iO9/5Trz33nupbB+AA3fFFVfE1772tc/8kf7KK69EUVFRHHvssbFjx44az7322mtRVFQUDzzwwBeu/913342ioqJ45JFHat1TbWuee+65+OEPf1jr9QLQOCxfvjwuv/zyKCkpif79+8fpp58e1113Xbzxxhv7va7XX389/uEf/qEeuozYsmVL/PCHP4xly5bVy/phXwRZUE9eeOGFWLBgQdptAHAABg8eHFu2bInXX3+9xvjChQujQ4cOUVFREUuWLKnx3NKlSyMiYsiQIV+4/q5du8aDDz4Yw4YNq7Oe97jvvvvi/fffr/P1AlB/7r777hgzZkxs27YtpkyZEvfcc09ceuml8ec//zlGjBgRv/vd7/ZrfU888USsWLGiXnp95ZVX4j//8z9j9+7d9bJ+2BdBFgDAPgwePDgiIl566aUa4wsXLoyvf/3r0aNHj1i4cGGN55YtWxaHHXZY9OjR4wvXX1BQEMcdd1x06tSp7poGIJPmz58ft9xyS3z3u9+Ne+65J84666woLi6OUaNGVX/oMXny5Fi7dm3arUKqBFnkjUceeST69u0bK1eujNGjR0f//v1j2LBh8etf/7p6mT2Xa/zud7+LSy+9NI499tgYOnRo3HHHHTU+aTjttNNi8uTJn1l/UVFRvPvuu/HII4/ElClTIiLi9NNP/8yyAGTDYYcdFoceemiNIGvr1q2xYsWKGDRoUJSUlMTzzz9fo2bZsmVRUlISERGlpaXxz//8z1FcXBzHHntsjBs3Lv785z9XL7u3ywRXrFgRY8aMieOOOy6GDRsW/+///b+46KKLPnMsWb9+fVxxxRUxYMCAKC4ujh/96Eexbdu2iIgYO3ZsLFmyJJYsWRJFRUXx4osv1vnvBoC69ctf/jKOOOKIuOKKKz7zXMuWLeP666+Pgw46qPr8paioKO64444ay33y1ip33HFH/PKXv/zMskVFRTF79uz44Q9/GAMGDIjBgwfHT37yk6ioqKhez9ixY2Ps2LE11v3iiy9WH1NefPHF+Na3vhUREd/61rc+syzUJ0EWeWX37t3x/e9/P84888y4++6744QTToibb775M5+mT5s2Ldq1axd33HFHnHvuuXHnnXfGz3/+81pvZ9iwYfHd7343Ij4+IE2cOLFOXwcADWfQoEE1gqzFixfHrl27YvDgwTFkyJB44403orS0NCIi3n777fjrX/8aQ4YMibKysrjwwgtj9erV8aMf/ShuueWW2L17d4wZM2af9zl544034qKLLoqIiFtvvTUuv/zyuPvuu2P58uWfWfb222+PL3/5y3HnnXfGt771rfjNb35TfZIyderU6Nu3b/Tt2zcefPDBOProo+v4twJAXSorK4s//elPceqpp0azZs32ukzHjh1j8ODB8dxzz9VqnaNGjYrzzz8/IiIefPDBGDVqVPVzt99+e2zcuDFuu+22mDBhQvzmN7+JSZMm1brfo48+On784x9HRMSPf/zjmDp1aq1r4UC1SLsBaEi5XC4mTpxYvRM/4YQT4plnnokFCxbEySefXL1c37594+abb46IiFNOOSW2bdsWs2fPjokTJ8bBBx/8hdvp1KlTHHbYYRER8dWvfjX+z//5P/XwagBoCIMHD46HH3441q9fH126dImFCxdG//79o0OHDjFo0KBo0aJFLFy4MEaPHh1Lly6NFi1axEknnRS//vWvY9OmTfHAAw/EoYceGhEfH1POPPPMuP3222PmzJmf2dZdd90V7dq1i1mzZkVhYWFERBx55JFx4YUXfmbZM844o3r276BBg+KPf/xjLF68OCIievbsGe3atYuIiOOOO64+fi0A1KE9XxD1RecNX/nKV+K5556LzZs3f+E6u3fvHt27d4+Izx4LOnXqFL/61a+iRYsWMXTo0GjevHnMmDEj1q5dG7169frCdbdr1y569uwZER8fc/b8NzQEM7LIOwMGDKj+74KCgujUqVP1pRh7/N//+39rPD7jjDNi586d8T//8z8N0SIAjchJJ50UzZo1q75Z7vPPP199I/d27drFMcccEy+88EJEfHyj92OOOSbatWsXixYtiq9+9avRrVu3qKqqiqqqqmjevHmccsop1ct/2uLFi2Po0KHVIVbEx8etPUHYJw0cOLDG4x49esSWLVvq5DUD0LD2fDtuy5YtP3e5gw46qMbySX3zm9+MFi3+/3ktZ5xxRkSEbyAkE8zIIu+0bt26xuPmzZt/5kDQtWvXGo/33ITXCQJA/vnSl74UvXv3jpdeeil69+4d77zzTo1vJBwyZEjMnj07crlcLFu2LEaMGBEREZs2bYq33357n5f1bd++/TNjZWVl8aUvfekz4126dPnM2CfDroi9H88AyIY9H1jsmZm1L++88060adMmOnTocEDb+/T5zp5jj/MdskCQBXuxadOmGo83btwYEVHj5GLXrl01lvn0rC4Amo7BgwfHypUro0ePHtG+ffs49thjq58bMmRIzJw5MxYvXhzvvvtudcjVvn37KC4ujquvvnqv6ywoKPjMWPfu3auPOZ+0cePGOOKII+ro1QDQ2HzpS1+K4447Lp5++un4/ve/v9f7ZJWXl8cf//jHOP3006vHkp6TfPp8Z8OGDRERNb5F1/kOjZVLC2Ev/vu//7vG46eeeioKCwurT1zatWsXH3zwQY1lPv3V7M2b++cF0FQMGjQoXnnllVi8eHEMHjy4+tKOiKi+X9bcuXPj4IMPjv79+0dERHFxcfzlL3+JI444Ivr371/981//9V/x0EMP1VjHHl/72tfiD3/4Q+zYsaN67JVXXol33313v3t2HALIlu9973vx5ptvxm233faZ53bt2hVTp06NioqKmDBhQkQc2DnJ3s53mjVrFieddFKt17234xg0BDOyYC+efPLJ6Ny5cwwdOjSWLFkSc+bMiSuvvDLatGkTERGnnnpq3HXXXfGrX/0qjjvuuFiwYEEsWrSoxjr23BT+mWeeiVNOOSWOOuqoBn8dANSNr33ta1FVVRXz58+v/pamPZo3bx4nnXRSPPfcc3HaaadV/2F/0UUXxW9/+9u46KKL4tvf/nZ07Ngx5s2bF7/5zW+qb9L+aZdeemnMmzcvJkyYEN/+9rdjy5Ytcfvtt0ezZs32+S1W+3LwwQfHihUrYtGiRdG3b9845JBDkr14ABrEySefHJMnT46f//zn8ec//zlGjBgRXbt2jXfffTceeOCBeOWVV2L69OnRp0+fiPj4m9J/97vfxTHHHBNHHHFEPProo/H222/XWOeec5LHH388jj322OjRo0dERLz88stx1VVXxTnnnBOvvvpqzJw5My644ILq50899dT47//+75g+fXr8/d//fSxfvjz+8z//s8a627dvHxERCxYsiEMOOaS6L6hvPqqDvfinf/qneOONN2LixInx1FNPxY9//OO45JJLqp//zne+E6NGjYp77703vvvd78aHH34Y06dPr7GOE088MQYPHhy33HJL3HjjjQ39EgCoQ23atIljjz02du7cGSUlJZ95fsiQIZ95rlu3bjF37tw49NBDY9q0aXHppZfGyy+/HNOnT4+LLrpor9v5yle+Evfcc0/s2LEjrrjiivjFL34RF198cXTp0iXatm27Xz2PGTMmWrZsGRdffHH84Q9/2K9aANIxfvz4eOCBB6Jdu3Zx4403xvjx42PmzJnRu3fveOSRR+Kcc86pXnbKlClx2mmnxU033RRXXHFFFBYWxg9+8IMa6/v6178e/fv3j8mTJ8c999xTPT5u3LioqqqK733vezF79uy49NJLY+rUqdXPjxw5Mi6++OKYN29eXHzxxfHSSy/F7bffXmPdvXr1irPOOivmzJkTV111VT39RuCzmuXcFRSqvfvuu3H66afHjBkz4rzzzku7HQDyzKJFi6Jly5Y1vpFw8+bNUVJSEldffXV861vfSrE7AJqCoqKi+N73vheXX3552q1AIi4tBABoJFavXh0zZ86Mf/7nf46jjz46/va3v8W9994b7du3j7POOivt9gAAUifIAgBoJL797W9HZWVlPPDAA/H+++9HmzZtori4OG688cYa3yQFAJCvXFoIAAAAQCa42TsAAAAAmSDIAgAAACATBFkAAAAAZEIqN3sfOHBgVFZWRpcuXdLYPECTs379+igoKIhly5al3Uqj4VgDULcca2pynAGoW7U9zqQSZO3YsSN27NgRb775ZhqbB2hyWrZsGb67o6YdO3bEzl07oyz+lnYrjcamso5pt9DoHNnG3yKf9LfStDtoXFodWZh2C43KzqpdjjWfsGPHjqisrIz33nsv7Vbg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EWVlZYnqDjrooER1K1eubNDtRUTs3LkzcS35wYwsAAAAADJBkAUAAABAJgiyAACAvFNWVhbDhw+PF198sXps6tSp0a9fvxgwYED1z4MPPphilwB8mntkAQAAeWX58uUxefLkWLduXY3xVatWxQ033BAjRoxIqTMAvogZWQAAQN549NFH46qrroorr7yyxnhlZWW89tpr0a9fv5Q6A6A2zMiiXg0bNmy/lp86dWr9NHIAFixYkHYLAADUkSFDhsTZZ58dLVq0qBFmrVmzJqqqqmLmzJmxfPnyaN++fYwcOTImTJgQzZv7/B+gsRBkAQAAeaNLly57Hf/oo4+iuLg4xo4dG7feemu88sorcdlll0Xz5s1jwoQJDdwlAPviowUAACDvlZSUxP333x/FxcXRsmXLOOaYY2LcuHExb968tFsD4BMEWQAAQN579tlnY+7cuTXGKisro3Xr1il1BMDeCLIAAIC8l8vlYsaMGbFo0aLI5XKxYsWKuP/++2P06NFptwbAJ7hHFgAAkPeGDx8eU6ZMiWnTpsWHH34YnTt3jssvvzzOOeectFsD4BMEWQAAQF569dVXazy+8MIL48ILL0ypGwBqw6WFAAAAAGSCGVkAAAA0CgUFBYlrO3XqlKiue/fuieoOOeSQRHV//etfE9VFRLz//vuJ6t54441EdW+99Vaiut27dyeqi4jYvn174lrygxlZAAAAAGSCIAsAAACATBBkAQAAAJAJ7pFFvRo2bFjaLRywpvAaAAAAoCkwIwsAAACATBBkAQAAAJAJgiwAMmXRokUxatSoOP7446OkpCRuuOGGqKioSLstAACgAQiyAMiMsrKy+M53vhP/8A//EMuWLYtHH300lixZEnfffXfarQEAAA3Azd4ByIxOnTrFCy+8EO3atYtcLhebNm2KHTt2RKdOndJuDQAAaACCLAAypV27dhERMXTo0Pjwww9j4MCBcd5556XcFQAA0BBcWghAJj399NPxhz/8IZo3bx5XXHFF2u0AAAANQJAFQCa1bt06unXrFpMmTYqFCxfG5s2b024JAACoZ4IsADLjpZdeim984xtRWVlZPVZZWRktW7aMwsLCFDsDAAAagntkAZAZRUVFUVFREbfcckv84Ac/iPXr18eNN94Y559/fhQUFKTdHgBwgDZt2pS49tBDD01U9+UvfzlRXVFRUaK6r371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bNmytNsAAAAamCALgExZtGhRPP300/H1r3897VYAAIAGtl9B1po1a2L8+PFRXFwcJSUlcfXVV0dZWVlEREydOjX69esXAwYMqP558MEH66VpAPLTxo0b49prr41bbrklCgsL024HAABoYLUOsioqKmLChAkxYMCAeP755+Pxxx+PTZs2xTXXXBMREatWrYobbrghVqxYUf0zevToemscgPyye/fumDRpUowfPz769OmTdjsAAEAKah1klZaWRp8+feKyyy6LgoKC6NixY4wePTqWLl0alZWV8dprr0W/fv3qs1cA8thdd90VBQUFMXbs2LRbAQAAUtKitgseeeSRMWvWrBpjTz31VBx99NGxZs2aqKqqipkzZ8by5cujffv2MXLkyJgwYUI0b+42XAAcuN/+9rfx17/+NQYOHBgRH88Ujoh49tln3fgdAADyRK2DrE/K5XJx2223xfz582P27NmxYcOGKC4ujrFjx8att94ar7zySlx22WXRvHnzmDBhQl33DEAeevLJJ2s8njx5ckRE/OxnP0ujHQAAIAX7HWSVl5fHlClTYvXq1TF79uwoKiqKoqKiKCkpqV7mmGOOiXHjxsW8efMEWQAAAADUif0KstatWxcXX3xx/N3f/V08/PDD0alTp4j4+LKODRs2xIUXXli9bGVlZbRu3bpuuwWA/2UmFgA0PX/7298S1y5evDhR3Z7bFeyvpOe7uVwuUV1ExF//+tdEdVVVVYnqWrZsmahu586dieqgNmp9A6vNmzfHuHHj4vjjj4977rmnOsSK+Pgf4owZM2LRokWRy+VixYoVcf/99/vWQgAAAADqTK1nZD3yyCNRWloaTzzxxGfuU7JixYqYMmVKTJs2LT788MPo3LlzXH755XHOOefUecMAAAAA5KdaB1njx4+P8ePH7/P5Cy+8sMalhQAAAABQl2p9aSEAAAAApEmQBQAAAEAmCLIAAAAAyARBFgAAAACZIMgCAAAAIBMEWQAAAABkgiALAAAAgEwQZAEAAACQCYIsAAAAADJBkAUAAABAJgiyAAAAAMiEFmk3AAAAABERbdu2TVxbWFiYqG7jxo2J6tavX5+o7oMPPkhUFxGxdevWxLVJtGrVqkG3B7VhRhYAAAAAmSDIAgAAACATBFkAAAAAZIIgCwAAAIBMEGQBAAAAkAmCLAAAAAAyQZAFAAAAQCYI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"/>

### Pooling

- `F.max_pool2d` 

  - `stride`



  - `kernel_size`



- `torch.nn.MaxPool2d` 도 많이 사용



```python
image.shape
```

<pre>
(28, 28)
</pre>

```python
pool = F.max_pool2d(output,2,2)
pool.shape
```

<pre>
torch.Size([1, 20, 12, 12])
</pre>
- MaxPool Layer는 weight가 없기 때문에 바로 `numpy()`변환 가능



```python
pool_arr = pool.numpy()
pool_arr.shape
```

<pre>
(1, 20, 12, 12)
</pre>

```python
plt.figure(figsize=(10,15))

plt.subplot(121)
plt.title("Input")
plt.imshow(image,'gray')
plt.subplot(122)
plt.title("Output")
plt.imshow(pool_arr[0,0,:,:],'gray')
```

<pre>
<matplotlib.image.AxesImage at 0x2aa89caec10>
</pre>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAy8AAAGZCAYAAACAIQ5xAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjYuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8o6BhiAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAprElEQVR4nO3df5DVBb0//hewrLuABQTo9V7uNQWWq2Ct0qIsBajEDGpqaFhEuDOkBVo6gYKg4FVEU9PQKTU0M5iwHLERkR8WWCbyQxGNWkUdQ91CYIfNhVZ+7Pn+0dfts/kLlrPnzfucx2OGGc/7vPe8nqdz4r1P3r/aZDKZTAAAABzi2iYdAAAAYH8oLwAAQCooLwAAQCooLwAAQCooLwAAQCooLwAAQCooLwAAQCooLwAAQCooL5AA94YFIJtae7tiu8WhQnmh4Nxxxx1RVlaWyOy//e1vcfHFF8dbb72VyHwADg3PPvtsXHrppVFZWRn9+/eP0047LaZPnx6vvvrqAb/WK6+8El/96ldbIWXE3//+97jyyitj3bp1rfL6cKCUF8ihp59+OlauXJl0DAASdM8998SYMWNi165dMXXq1Lj33nvjW9/6VvzpT3+Kc889Nx577LEDer3HH3881q9f3ypZ//znP8cjjzwSjY2NrfL6cKCKkg4AAFAoVqxYEbfeemtMmDAhvvvd7zYtr6ioiHPOOSe+973vxZQpU6JPnz7Ru3fvBJPCocmeFwraww8/HMcdd1xs2LAhRo8eHf3794+hQ4fGT37yk6Z13nzzzSgrK4vHHnssvvWtb8VnPvOZGDJkSNxxxx3N/iXq1FNPjSlTprzv9cvKyuLNN9+Mhx9+OKZOnRoREaeddtr71gUg/915553x6U9/Or7zne+877n27dvHtddeG+3atWvaDpWVlcUdd9zRbL3/9/DnO+64I+688873rVtWVhbz5s2LK6+8MsrLy2PQoEFx/fXXR0NDQ9PrjB07NsaOHdvstVevXh1lZWWxevXqWL16dXzjG9+IiIhvfOMb71sXkqC8UPAaGxvjsssui5EjR8Y999wTJ510Utxyyy3x+9//vtl6M2fOjE6dOsUdd9wR55xzTvzoRz+K73//+/s9Z+jQofHtb387Iv658ZowYUJW3wcAh7ba2tr44x//GMOGDYs2bdp84DpdunSJQYMGxW9+85v9es3zzz8/zjvvvIiIePDBB+P8889veu6HP/xhbN++PW6//fYYP358/PKXv4zJkyfvd97jjz8+rrnmmoiIuOaaa2LGjBn7/bPQWhw2RsHLZDIxYcKEpr/wTzrppFi+fHmsXLkyPv/5zzetd9xxx8Utt9wSERFf+MIXYteuXTFv3ryYMGFCfOITn/jYOV27do3//u//joiI//3f/43/+q//aoV3A8Ch6r2LtXzc3///8z//E7/5zW+irq7uY1/zyCOPjCOPPDIiIj772c82e65r165x1113RVFRUQwZMiTatm0bs2fPjk2bNu3XIWmdOnWKXr16RUREr169mv4bkmTPC0REeXl5038XFxdH165dY9euXc3W+dKXvtTs8YgRI2LPnj3x/PPP5yIiACn33uWG27dv/5HrtWvXrtn6LXXGGWdEUdG//p16xIgRERGuHEaqKS8QESUlJc0et23b9n0bjR49ejR73LVr14j452UkAeDj/Od//mdExMdeLv+NN96IDh06ROfOnQ9q3r9vtz71qU9FhO0W6aa8wH7asWNHs8fbt2+PiH9tDCIi9u3b12ydf997A0Dh+tSnPhWf/exnY9myZR+6V6W+vj7+8Ic/xGmnnda0rKXbln/fbm3bti0i/vWPbwfz2pAU5QX2029/+9tmj5cuXRqlpaXxmc98JiL+eWzw3/72t2brPPfcc80et23r/3IAheySSy6J1157LW6//fb3Pbdv376YMWNGNDQ0xPjx4yPi4LYtH7TdatOmTZx88sn7/drvHcIGhwon7MN+WrJkSXTr1i2GDBkSa9asifnz58fll18eHTp0iIiIYcOGxd133x133XVXfPazn42VK1fGqlWrmr3Geyf2L1++PL7whS/Esccem/P3AUByPv/5z8eUKVPi+9//ftNNKXv06BFvvvlm/OIXv4g///nPMWvWrOjbt29E/PNKlY899liccMIJ8elPfzoWLlwYf/nLX5q95nvblkWLFsVnPvOZ6NmzZ0REvPDCCzFp0qQ4++yz46WXXoo5c+bEV77ylabnhw0bFr/97W9j1qxZcfrpp8ezzz4bjzzySLPXPvzwwyMiYuXKlfHJT36yKRckRXmB/fTd73431qxZEw8++GD8x3/8R1xzzTXx1a9+ten5iy++OGpra+O+++6LPXv2xNChQ2PWrFlNl0eOiBg4cGAMGjQobr311li1alXcc889SbwVABJUVVUV5eXl8bOf/SxuuummqK2tje7du0dlZWXMmjWr2VW9pk6dGnv37o2bb745ioqKYuTIkfG9730vpk+f3rTOF7/4xfj1r38dU6ZMifPOOy9mzpwZERHjxo2LLVu2xCWXXBJdunSJb33rW3HxxRc3/dyoUaNi8+bNsXDhwnjwwQejoqIifvjDHzbbtvXu3TvOPPPMmD9/fvz+97+PRYsWtf7/QPAR2mQO9lIWkOfefPPNOO2002L27Nnx5S9/Oek4APCxysrK4pJLLolLL7006SiQVQ7ABwAAUkF5AQAAUsFhYwAAQCrY8wIAAKSC8gIAAKSC8gIAAKRCIvd5GTBgQOzevTu6d++exHiAgrZ169YoLi6OdevWJR3lkGLbBJCMA9kuJVJe3n333Xj33XfjtddeS2I8QEFr3759uFbL+723bXr99deTjgIt0tjYmMjckpKSnM/s0KFDzmdGROzcuTPnM/fs2ZPzmbnWrl27aGho2K91EykvPXr0iNdee80GAiABRx99dPTs2TPpGIecHj16xOuvvx5vv/120lGgRerr6xOZW1lZmfOZI0eOzPnMiIiFCxfmfGZ1dXXOZ+Zajx499nvdrJ7zsn379pgwYUIMGDAgBg4cGLNmzYq9e/dmcwQAAFCgslpeLrvssujQoUP8/ve/j4ceeihWrVoV999/fzZHAAAABSpr5eUvf/lLrFmzJiZPnhylpaXRs2fPmDBhQsyfPz9bIwAAgAKWtfKyadOm6Ny5cxxxxBFNy4499tioqamJv//979kaAwAAFKislZedO3dGaWlps2XvPd61a1e2xgAAAAUqa+WlQ4cO8Y9//KPZsvced+zYMVtjAACAApW18tK7d+/YsWNHbNu2rWnZq6++GkceeWQcfvjh2RoDAAAUqKyVl6OPPjpOOumkuOGGG6K+vj7eeOON+NGPfhTnnXdetkYAAAAFLKuXSp4zZ07s3bs3TjvttPjKV74Sn//852PChAnZHAEAABSoomy+WLdu3WLOnDnZfEkAOCjbt2+Pq6++OtasWRPt2rWLL33pS3HllVdGUVFWN4EA5EBW97wAwKHGDZQB8ofyAkDecgNlgPyivACQt9xAGSC/KC8A5C03UAbIL8oLAHnLDZQB8ovyAkDecgNlgPyivACQt9xAGSC/KC8A5DU3UAbIH+7QBUBecwNlgPxhzwsAAJAKygsAAJAKygsAAJAKygsAAJAKygsAAJAKygsAAJAKygsAAJAK7vMCAJAHPvWpTyUy9+yzz875zMcffzznMyMi3nrrrUTm8i/2vAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKmgvAAAAKlQlHQA4MMNHTr0gNZfsWLFAc+49tprD/hnZs6cecA/AwBwsOx5AQAAUkF5AQAAUkF5AQAAUkF5AQAAUkF5AQAAUkF5AQAAUkF5AQAAUkF5AQAAUsFNKgEA8sCAAQMSmXv66afnfGZJSUnOZ0ZE3HrrrYnM5V/seQEAAFJBeQEAAFJBeQEAAFLBOS9wCFuxYkWrz5gxY0arz5g5c2arzwAA8p89LwAAQCooLwAAQCpktbwsXrw4jjvuuCgvL2/6M3ny5GyOAAAAClRWz3l58cUX4+yzz47Zs2dn82UBAACyu+flxRdfjH79+mXzJQEAACIii3teGhsbY+PGjVFaWhpz586Nffv2xZAhQ2LSpEnxyU9+MltjAACAApW1PS+1tbVx3HHHxYgRI2Lx4sWxYMGCeP31153zAkCiqquro6qqKioqKqKysjKuuOKKqK2tTToWAC2QtfLSrVu3mD9/fpx33nlRWloaRx11VEyePDl+97vfRX19fbbGAMB+a2hoiPHjx0d5eXk89dRTsWjRotixY0dcddVVSUcDoAWyVl6qq6vjlltuiUwm07Rs9+7d0bZt2yguLs7WGADYbzU1NdG3b9+YOHFiFBcXR5cuXWL06NGxdu3apKMB0AJZKy+dO3eO+fPnx9y5c2Pv3r1RU1MTN998c5x77rnKCwCJOOaYY2Lu3LnRrl27pmVLly6N448/PsFUALRU1srLkUceGXfffXf85je/iYqKihg1alT0798/rrnmmmyNAIAWy2Qycdttt8WKFSti2rRpSccBoAWyep+XioqKWLBgQTZfEgAOWn19fUydOjU2btwY8+bNi7KysqQjAdACWS0vQGEYMmRI0hFgv23evDm++c1vxlFHHRUPPfRQdO3aNelIALRQVm9SCQCHkrq6uhg3blyceOKJce+99youAClnzwsAeevhhx+OmpqaePzxx2PJkiXNnlu/fn1CqQBoKeUFgLxVVVUVVVVVSccAIEscNgYAAKSC8gIAAKSC8gIAAKSC8gIAAKSC8gIAAKSC8gIAAKSC8gIAAKSC8gIAAKSCm1RCjsycOTPpCADkSH19fc5nnnjiiTmfGRHRt2/fnM987LHHcj4zIqJNmzaJzOVf7HkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSoSjpAED6XHvttUlHAAAKkD0vAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKhQlHQAKxYwZM5KOkDUrV65MOgIAUIDseQEAAFJBeQEAAFJBeQEAAFJBeQEAAFLBCfsAAFnWvn37nM+cPn16zmdGRKxevTrnM//0pz/lfGZERLt27RKZy7/Y8wIAAKSC8gIAAKSC8gIAAKSC8gIAAKSC8gIAAKSC8gIAAKSC8gIAAKSC+7xACwwdOjTpCFlz7bXXJh0BAGC/2PMCAACkgvICAACkQovLS21tbQwfPjxWr17dtGzDhg1x/vnnR3l5eZx66qnxq1/9KishAeBg7du3L8aOHRtTpkxJOgoALdSi8vLss8/G6NGjY/PmzU3L6urq4qKLLopzzjkn1q5dG7NmzYrZs2fHCy+8kLWwANBSd955Z6xbty7pGAAchAMuLwsXLoxJkybF5Zdf3mz5smXLonPnzjFmzJgoKiqKU045Jc4666yYP39+1sICQEusWrUqli1bFl/84heTjgLAQTjg8jJ48OBYvnx5jBw5stnyTZs2RZ8+fZot69WrV1RXVx9cQgA4CNu3b49p06bFrbfeGqWlpUnHAeAgHPClkrt37/6By3fu3Pm+jUJJSUns2rWrZckA4CA1NjbG5MmTo6qqKvr27Zt0HAAOUtauNlZaWhoNDQ3NljU0NETHjh2zNQIADsjdd98dxcXFMXbs2KSjAJAFWbtJZZ8+feIPf/hDs2WvvPJK9O7dO1sjAOCA/PrXv4633347BgwYEBHR9I9sTzzxhJP3AVIoa3tehg8fHtu2bYv7778/9uzZE88880w8+uijMWrUqGyNAIADsmTJknjuuedi3bp1sW7dujjzzDPjzDPPVFwAUipr5aVLly5x3333xZIlS2LgwIExffr0mD59epx88snZGgEAABSwgzps7KWXXmr2uH///rFgwYKDCgQAreXGG29MOgIAByFr57xAIZkxY0bSEbJm5syZSUcAANgvWTtsDAAAoDUpLwAAQCooLwAAQCooLwAAQCooLwAAQCooLwAAQCooLwAAQCq4zwsAkNfq6+tzPvPb3/52zmd26NAh5zMjIp5//vmcz/zDH/6Q85kREbW1tYnM5V/seQEAAFJBeQEAAFJBeQEAAFLBOS8QETNnzjyg9YcOHdoqOQ7WsGHDko4AANBq7HkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSQXkBAABSoSjpAHAoGDJkSNIRPtDKlStbdX0AgDSx5wUAAEgF5QUAAEgF5QUAAEgF5QUAAEgF5QUAAEgF5QUAAEgF5QUAAEgF5QUAAEgF5QUAAEgF5QUAAEgF5QUAAEiFoqQDQLYNHTo0Jz+TC08++WTSEQBSr2vXrjmfecstt+R85tKlS3M+MyKZbVX79u1zPpNDgz0vAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAABAKigvAOS1HTt2xBVXXBEDBw6Mz33uczFhwoR4++23k44FQAsUJR0Asm3FihVJR8iamTNnJh0BUu/SSy+NT37yk7F8+fJo27ZtTJ06Na6++uq4++67k44GwAFSXgDIW3/84x9jw4YN8fTTT0enTp0iIuK6666LrVu3JpwMgJZw2BgAeeuFF16IXr16xS9/+csYPnx4DB48OG666abo3r170tEAaIEWl5fa2toYPnx4rF69umnZjBkzol+/flFeXt7058EHH8xKUAA4UHV1dfHSSy/F66+/HgsXLoxHHnkktmzZEldeeWXS0QBogRYdNvbss8/GlClTYvPmzc2Wv/jii3HdddfFueeem5VwAHAwiouLIyJi2rRpcdhhh0WnTp3isssui6985Suxc+fO6NixY8IJATgQB7znZeHChTFp0qS4/PLLmy3fvXt3vPzyy9GvX7+shQOAg9GrV69obGyMPXv2NC1rbGyMiIhMJpNULABa6IDL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Zd55553MJZdckrnooouSjpVV+/bty1RWVmZ+9rOfZfbt25f561//mhkxYkTmzjvvTDpa1hTS71aHxJ6Xv/zlL7FmzZqYPHlylJaWRs+ePWPChAkxf/78pKPlxIsvvhj9+vVLOkZOLFy4MCZNmhSXX355s+XLli2Lzp07x5gxY6KoqChOOeWUOOuss/LqO/Bh73337t3x8ssv5+13oKamJvr27RsTJ06M4uLi6NKlS4wePTrWrl2b95/7R733fP/cC0WhbL8+6rucj1atWhXLli2LL37xi0lHaVV//OMfY8OGDXHjjTfGJz7xiejUqVNcd911MWnSpKSjZVVdXV1s3bo1GhsbI/P/3yGkbdu2UVpamnCy7Ci0360OifKyadOm6Ny5cxxxxBFNy4499tioqamJv//97wkma32NjY2xcePGWLlyZQwbNiy+8IUvxNVXXx11dXVJR2sVgwcPjuXLl8fIkSObLd+0aVP06dOn2bJevXpFdXV1LuO1qg9779XV1bF3796YM2dODBo0KEaMGBH33HNPNDY2JpQ0u4455piYO3dus7vnLl26NI4//vi8/9w/6r3n++deKApl+/VR3+V8s3379pg2bVrceuutefPL7Yd54YUXolevXvHLX/4yhg8fHoMHD46bbrop727U2qVLl7jwwgvjpptuiv79+8eQIUPi6KOPjgsvvDDpaFlRaL9bHRLlZefOne/7C+K9x7t27UoiUs7U1tbGcccdFyNGjIjFixfHggUL4vXXX8/bc166d+8eRUVF71v+Qd+BkpKSvPr8P+y9v/POO1FRURFjx46NJ598Mm6++eb4+c9/Hvfdd18CKVtXJpOJ2267LVasWBHTpk0riM/9Pf/+3gvpc89nhbj9+vfvcj5pbGyMyZMnR1VVVfTt2zfpOK2urq4uXnrppXj99ddj4cKF8cgjj8SWLVviyiuvTDpaVjU2NkZJSUlcffXV8fzzz8eiRYvi1VdfjTlz5iQdLSsK7XerQ6K8dOjQIf7xj380W/be444dOyYRKWe6desW8+fPj/POOy9KS0vjqKOOismTJ8fvfve7qK+vTzpezpSWlkZDQ0OzZQ0NDXn/+UdEVFZWxgMPPBAVFRXRvn37OOGEE2LcuHGxePHipKNlVX19fXznO9+JRx99NObNmxdlZWUF87l/0HsvlM893xXa9uuDvsv55O67747i4uIYO3Zs0lFyori4OCIipk2bFp06dYpu3brFZZddFk8++WTs3Lkz4XTZs3z58li6dGl87Wtfi+Li4ujdu3dMnDgxfvGLXyQdrVXl6zb2kCgvvXv3jh07dsS2bdualr366qtx5JFHxuGHH55gstZXXV0dt9xyS9MxmBH/PAeibdu2TX+pFII+ffrEpk2bmi175ZVXonfv3gklyp0nnngiFixY0GzZ7t27o6SkJKFE2bd58+YYNWpU1NfXx0MPPdT0C08hfO4f9t4L4XMvBIW0/fqw73I++fWvfx1r1qyJAQMGxIABA2LRokWxaNGiGDBgQNLRWkWvXr2isbEx9uzZ07TsvUNX/9/fS9Lur3/96/uuLFZUVBTt27dPKFFu5Os29pAoL0cffXScdNJJccMNN0R9fX288cYb8aMf/SjOO++8pKO1us6dO8f8+fNj7ty5sXfv3qipqYmbb745zj333IIqL8OHD49t27bF/fffH3v27IlnnnkmHn300Rg1alTS0VpdJpOJ2bNnx6pVqyKTycT69evjgQceiNGjRycdLSvq6upi3LhxceKJJ8a9994bXbt2bXou3z/3j3rv+f65F4pC2X591Hc5nyxZsiSee+65WLduXaxbty7OPPPMOPPMM2PdunVJR2sVgwYNip49e8ZVV10VO3fujNra2rjtttvi9NNPj06dOiUdL2sGDx4cW7dujbvuuiv27dsXb7zxRvz4xz+Os846K+lorSpft7FtModItd62bVv83//9X6xevTratm0b55xzTkyaNKnZyYH5as2aNfGDH/wgXn755TjssMPijDPOiMmTJ8dhhx2WdLRWVVZWFg888EAMHDgwIv551bVZs2bFyy+/HF27do0JEybEl7/85YRTto5/f+8LFiyIn/70p7Fly5bo1q1bVFVVxZgxYxJOmR0//elP48Ybb4zS0tJo06ZNs+fWr1+f15/7x733fP7cC0khbL8+7rucr967x8uNN96YcJLWs2XLlrjxxhtj7dq18e6778app54a06ZNi0984hNJR8uqp59+Om6//fZ47bXX4vDDD48vfelLTVfPyyeF8LvVIVNeAAAAPsohcdgYAADAx1FeAACAVFBeAACAVFBeAACAVFBeAACAVFBeAACAVFBeAACAVFBeAACAVFBeAACAVFBeAACAVFBeAACAVPj/AAmw/orKSYefAAAAAElFTkSuQmCC"/>

### Linear

- 1d만 가능 `.view()`를 통해 1D로 펼쳐줘야함



```python
image = torch.from_numpy(image)
image.shape
```

<pre>
torch.Size([28, 28])
</pre>

```python
flatten = image.view(1,28*28)
flatten.shape
```

<pre>
torch.Size([1, 784])
</pre>

```python
lin = nn.Linear(784,10)(flatten)
lin.shape
```

<pre>
torch.Size([1, 10])
</pre>

```python
lin
```

<pre>
tensor([[ 0.3404,  0.8093, -0.5194,  0.1211, -0.0194, -0.9303,  0.5611, -0.0746,
         -0.6443, -0.0583]], grad_fn=AddmmBackward0)
</pre>

```python
plt.imshow(lin.detach().numpy(),'jet')
plt.colorbar()
plt.show()
```

<img src="data:image/png;base64,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"/>

### Softmax



```python
with torch.no_grad():
    flatten = image.view(1,28*28)
    lin = nn.Linear(784,10)(flatten)
    softmax = F.softmax(lin,dim=1)
```


```python
softmax
```

<pre>
tensor([[0.0192, 0.0783, 0.1115, 0.0262, 0.1845, 0.1473, 0.0695, 0.1572, 0.1597,
         0.0464]])
</pre>

```python
np.sum(softmax.numpy())
```

<pre>
1.0
</pre>
### F.relu



- ReLU 함수를 적용하는 레이어



- `nn.ReLU`로도 사용 가능



```python
inputs = torch.randn(4,3,28,28).to(device)
inputs.shape
```

<pre>
torch.Size([4, 3, 28, 28])
</pre>

```python
layer = nn.Conv2d(3,20,5,1).to(device)
output = F.relu(layer(inputs))
output.shape
```

<pre>
torch.Size([4, 20, 24, 24])
</pre>
## Optimizer



- `import torch.optim as optim`



- `model`의 파라미터를 업데이트



- 예시)

  ```python

  optimizer = torch.optim.Adam(model.parameters(), lr=1e-4, weight_decay=1e-5)

  optimizer = optim.SGD(model.parameters(), lr=0.001)

  ```



- `.zero_grad()`로 초기화

- `.step()`으로 업데이트


